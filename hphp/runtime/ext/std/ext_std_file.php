<?hh
// @generated by docskel.php

/**
 * Returns trailing name component of path
 *
 * @param string $path - A path.   On Windows, both slash (/) and
 *   backslash (\) are used as directory separator character. In other
 *   environments, it is the forward slash (/).
 * @param string $suffix - If the name component ends in suffix this will
 *   also be cut off.
 *
 * @return string - Returns the base name of the given path.
 */
<<__Native>>
function basename(string $path,
                  string $suffix): string;

/**
 * Changes file group
 *
 * @param string $filename - Path to the file.
 * @param mixed $group - A group name or number.
 *
 * @return bool -
 */
<<__Native>>
function chgrp(string $filename,
               mixed $group): bool;

/**
 * Changes file mode
 *
 * @param string $filename - Path to the file.
 * @param int $mode - Note that mode is not automatically assumed to be
 *   an octal value, so to ensure the expected operation, you need to
 *   prefix mode with a zero (0). Strings such as "g+w" will not work
 *   properly.          The mode parameter consists of three octal number
 *   components specifying access restrictions for the owner, the user
 *   group in which the owner is in, and to everybody else in this order.
 *   One component can be computed by adding up the needed permissions for
 *   that target user base. Number 1 means that you grant execute rights,
 *   number 2 means that you make the file writeable, number 4 means that
 *   you make the file readable. Add up these numbers to specify needed
 *   rights. You can also read more about modes on Unix systems with 'man 1
 *   chmod' and 'man 2 chmod'.
 *
 * @return bool -
 */
<<__Native>>
function chmod(string $filename,
               int $mode): bool;

/**
 * Changes file owner
 *
 * @param string $filename - Path to the file.
 * @param mixed $user - A user name or number.
 *
 * @return bool -
 */
<<__Native>>
function chown(string $filename,
               mixed $user): bool;

/**
 * Clears file status cache
 *
 * @param bool $clear_realpath_cache - Whether to clear the realpath
 *   cache or not.
 * @param string $filename - Clear the realpath and the stat cache for a
 *   specific filename only; only used if clear_realpath_cache is TRUE.
 *
 * @return void -
 */
<<__Native>>
function clearstatcache(bool $clear_realpath_cache = false,
                        string $filename): void;

/**
 * Copies file
 *
 * @param string $source - Path to the source file.
 * @param string $dest - The destination path. If dest is a URL, the copy
 *   operation may fail if the wrapper does not support overwriting of
 *   existing files.    If the destination file already exists, it will be
 *   overwritten.
 * @param resource $context - A valid context resource created with
 *   stream_context_create().
 *
 * @return bool -
 */
<<__Native>>
function copy(string $source,
              string $dest,
              resource $context): bool;

/**
 * Returns parent directory's path
 *
 * @param string $path - A path.   On Windows, both slash (/) and
 *   backslash (\) are used as directory separator character. In other
 *   environments, it is the forward slash (/).
 *
 * @return string - Returns the path of the parent directory. If there
 *   are no slashes in path, a dot ('.') is returned, indicating the
 *   current directory. Otherwise, the returned string is path with any
 *   trailing /component removed.
 */
<<__Native>>
function dirname(string $path): string;

/**
 * Returns available space on filesystem or disk partition
 *
 * @param string $directory - A directory of the filesystem or disk
 *   partition.    Given a file name instead of a directory, the behaviour
 *   of the function is unspecified and may differ between operating
 *   systems and PHP versions.
 *
 * @return float - Returns the number of available bytes as a float .
 */
<<__Native>>
function disk_free_space(string $directory): float;

/**
 * Returns available space on filesystem or disk partition
 *
 * @param string $directory - A directory of the filesystem or disk
 *   partition.    Given a file name instead of a directory, the behaviour
 *   of the function is unspecified and may differ between operating
 *   systems and PHP versions.
 *
 * @return float - Returns the number of available bytes as a float .
 */
<<__Native>>
function diskfreespace(string $directory): float;

/**
 * Returns the total size of a filesystem or disk partition
 *
 * @param string $directory - A directory of the filesystem or disk
 *   partition.
 *
 * @return float - Returns the total number of bytes as a float .
 */
<<__Native>>
function disk_total_space(string $directory): float;

/**
 * Closes an open file pointer
 *
 * @param resource $handle - The file pointer must be valid, and must
 *   point to a file successfully opened by fopen() or fsockopen().
 *
 * @return bool -
 */
<<__Native>>
function fclose(resource $handle): bool;

/**
 * Tests for end-of-file on a file pointer
 *
 * @param resource $handle -
 *
 * @return bool - Returns TRUE if the file pointer is at EOF or an error
 *   occurs (including socket timeout); otherwise returns FALSE.
 */
<<__Native>>
function feof(resource $handle): bool;

/**
 * Flushes the output to a file
 *
 * @param resource $handle -
 *
 * @return bool -
 */
<<__Native>>
function fflush(resource $handle): bool;

/**
 * Gets character from file pointer
 *
 * @param resource $handle -
 *
 * @return string - Returns a string containing a single character read
 *   from the file pointed to by handle. Returns FALSE on EOF.
 */
<<__Native>>
function fgetc(resource $handle): string;

/**
 * Gets line from file pointer and parse for CSV fields
 *
 * @param resource $handle - A valid file pointer to a file successfully
 *   opened by fopen(), popen(), or fsockopen().
 * @param int $length - Must be greater than the longest line (in
 *   characters) to be found in the CSV file (allowing for trailing
 *   line-end characters). It became optional in PHP 5. Omitting this
 *   parameter (or setting it to 0 in PHP 5.1.0 and later) the maximum line
 *   length is not limited, which is slightly slower.
 * @param string $delimiter - Set the field delimiter (one character
 *   only).
 * @param string $enclosure - Set the field enclosure character (one
 *   character only).
 * @param string $escape - Set the escape character (one character only).
 *   Defaults as a backslash.
 *
 * @return array - Returns an indexed array containing the fields read. 
 *    A blank line in a CSV file will be returned as an array comprising a
 *   single null field, and will not be treated as an error.    fgetcsv()
 *   returns NULL if an invalid handle is supplied or FALSE on other
 *   errors, including end of file.
 */
<<__Native>>
function fgetcsv(resource $handle,
                 int $length,
                 string $delimiter = ",",
                 string $enclosure = '"',
                 string $escape = "\\"): array;

/**
 * Gets line from file pointer
 *
 * @param resource $handle -
 * @param int $length - Reading ends when length - 1 bytes have been
 *   read, or a newline (which is included in the return value), or an EOF
 *   (whichever comes first). If no length is specified, it will keep
 *   reading from the stream until it reaches the end of the line.    Until
 *   PHP 4.3.0, omitting it would assume 1024 as the line length. If the
 *   majority of the lines in the file are all larger than 8KB, it is more
 *   resource efficient for your script to specify the maximum line length.
 *
 * @return string - Returns a string of up to length - 1 bytes read from
 *   the file pointed to by handle. If there is no more data to read in the
 *   file pointer, then FALSE is returned.   If an error occurs, FALSE is
 *   returned.
 */
<<__Native>>
function fgets(resource $handle,
               int $length): string;

/**
 * Gets line from file pointer and strip HTML tags
 *
 * @param resource $handle -
 * @param int $length - Length of the data to be retrieved.
 * @param string $allowable_tags - You can use the optional third
 *   parameter to specify tags which should not be stripped.
 *
 * @return string - Returns a string of up to length - 1 bytes read from
 *   the file pointed to by handle, with all HTML and PHP code stripped. 
 *   If an error occurs, returns FALSE.
 */
<<__Native>>
function fgetss(resource $handle,
                int $length,
                string $allowable_tags): string;

/**
 * Checks whether a file or directory exists
 *
 * @param string $filename - Path to the file or directory.   On windows,
 *   use //computername/share/filename or \\computername\share\filename to
 *   check files on network shares.
 *
 * @return bool - Returns TRUE if the file or directory specified by
 *   filename exists; FALSE otherwise.    This function will return FALSE
 *   for symlinks pointing to non-existing files.     This function returns
 *   FALSE for files inaccessible due to safe mode restrictions. However
 *   these files still can be included if they are located in
 *   safe_mode_include_dir.     The check is done using the real UID/GID
 *   instead of the effective one.
 */
<<__Native>>
function file_exists(string $filename): bool;

/**
 * Reads entire file into a string
 *
 * @param string $filename - Name of the file to read.
 * @param bool $use_include_path - As of PHP 5 the FILE_USE_INCLUDE_PATH
 *   constant can be used to trigger include path search.
 * @param resource $context - A valid context resource created with
 *   stream_context_create(). If you don't need to use a custom context,
 *   you can skip this parameter by NULL.
 * @param int $offset - The offset where the reading starts on the
 *   original stream.   Seeking (offset) is not supported with remote
 *   files. Attempting to seek on non-local files may work with small
 *   offsets, but this is unpredictable because it works on the buffered
 *   stream.
 * @param int $maxlen - Maximum length of data read. The default is to
 *   read until end of file is reached. Note that this parameter is applied
 *   to the stream processed by the filters.
 *
 * @return string - The function returns the read data .
 */
<<__Native>>
function file_get_contents(string $filename,
                           bool $use_include_path = false,
                           resource $context,
                           int $offset = -1,
                           int $maxlen): string;

/**
 * Write a string to a file
 *
 * @param string $filename - Path to the file where to write the data.
 * @param mixed $data - The data to write. Can be either a string, an
 *   array or a stream resource.   If data is a stream resource, the
 *   remaining buffer of that stream will be copied to the specified file.
 *   This is similar with using stream_copy_to_stream().   You can also
 *   specify the data parameter as a single dimension array. This is
 *   equivalent to file_put_contents($filename, implode('', $array)).
 * @param int $flags - The value of flags can be any combination of the
 *   following flags, joined with the binary OR (|) operator.    Available
 *   flags    Flag Description      FILE_USE_INCLUDE_PATH   Search for
 *   filename in the include directory. See include_path for more
 *   information.     FILE_APPEND   If file filename already exists, append
 *   the data to the file instead of overwriting it.     LOCK_EX   Acquire
 *   an exclusive lock on the file while proceeding to the writing.
 * @param resource $context - A valid context resource created with
 *   stream_context_create().
 *
 * @return int - This function returns the number of bytes that were
 *   written to the file, or FALSE on failure.
 */
<<__Native>>
function file_put_contents(string $filename,
                           mixed $data,
                           int $flags,
                           resource $context): int;

/**
 * Reads entire file into an array
 *
 * @param string $filename - Path to the file.
 * @param int $flags - The optional parameter flags can be one, or more,
 *   of the following constants:    FILE_USE_INCLUDE_PATH    Search for the
 *   file in the include_path.      FILE_IGNORE_NEW_LINES    Do not add
 *   newline at the end of each array element      FILE_SKIP_EMPTY_LINES  
 *   Skip empty lines
 * @param resource $context - A context resource created with the
 *   stream_context_create() function.
 *
 * @return array - Returns the file in an array. Each element of the
 *   array corresponds to a line in the file, with the newline still
 *   attached. Upon failure, file() returns FALSE.    Each line in the
 *   resulting array will include the line ending, unless
 *   FILE_IGNORE_NEW_LINES is used, so you still need to use rtrim() if you
 *   do not want the line ending present.
 */
<<__Native>>
function file(string $filename,
              int $flags,
              resource $context): array;

/**
 * Gets last access time of file
 *
 * @param string $filename - Path to the file.
 *
 * @return int - Returns the time the file was last accessed, . The time
 *   is returned as a Unix timestamp.
 */
<<__Native>>
function fileatime(string $filename): int;

/**
 * Gets inode change time of file
 *
 * @param string $filename - Path to the file.
 *
 * @return int - Returns the time the file was last changed, . The time
 *   is returned as a Unix timestamp.
 */
<<__Native>>
function filectime(string $filename): int;

/**
 * Gets file group
 *
 * @param string $filename - Path to the file.
 *
 * @return int - Returns the group ID of the file, or FALSE if an error
 *   occurs. The group ID is returned in numerical format, use
 *   posix_getgrgid() to resolve it to a group name. Upon failure, FALSE is
 *   returned.
 */
<<__Native>>
function filegroup(string $filename): int;

/**
 * Gets file inode
 *
 * @param string $filename - Path to the file.
 *
 * @return int - Returns the inode number of the file, .
 */
<<__Native>>
function fileinode(string $filename): int;

/**
 * Gets file modification time
 *
 * @param string $filename - Path to the file.
 *
 * @return int - Returns the time the file was last modified, . The time
 *   is returned as a Unix timestamp, which is suitable for the date()
 *   function.
 */
<<__Native>>
function filemtime(string $filename): int;

/**
 * Gets file owner
 *
 * @param string $filename - Path to the file.
 *
 * @return int - Returns the user ID of the owner of the file, . The user
 *   ID is returned in numerical format, use posix_getpwuid() to resolve it
 *   to a username.
 */
<<__Native>>
function fileowner(string $filename): int;

/**
 * Gets file permissions
 *
 * @param string $filename - Path to the file.
 *
 * @return int - Returns the file's permissions as a numeric mode. Lower
 *   bits of this mode are the same as the permissions expected by chmod(),
 *   however on most platforms the return value will also include
 *   information on the type of file given as filename. The examples below
 *   demonstrate how to test the return value for specific permissions and
 *   file types on POSIX systems, including Linux and Mac OS X.   For local
 *   files, the specific return value is that of the st_mode member of the
 *   structure returned by the C library's stat() function. Exactly which
 *   bits are set can vary from platform to platform, and looking up your
 *   specific platform's documentation is recommended if parsing the
 *   non-permission bits of the return value is required.
 */
<<__Native>>
function fileperms(string $filename): int;

/**
 * Gets file size
 *
 * @param string $filename - Path to the file.
 *
 * @return int - Returns the size of the file in bytes, or FALSE (and
 *   generates an error of level E_WARNING) in case of an error.
 */
<<__Native>>
function filesize(string $filename): int;

/**
 * Gets file type
 *
 * @param string $filename - Path to the file.
 *
 * @return string - Returns the type of the file. Possible values are
 *   fifo, char, dir, block, link, file, socket and unknown.   Returns
 *   FALSE if an error occurs. filetype() will also produce an E_NOTICE
 *   message if the stat call fails or if the file type is unknown.
 */
<<__Native>>
function filetype(string $filename): string;

/**
 * Portable advisory file locking
 *
 * @param resource $handle -
 * @param int $operation - operation is one of the following:    LOCK_SH
 *   to acquire a shared lock (reader).     LOCK_EX to acquire an exclusive
 *   lock (writer).     LOCK_UN to release a lock (shared or exclusive).  
 *     It is also possible to add LOCK_NB as a bitmask to one of the above
 *   operations if you don't want flock() to block while locking. (not
 *   supported on Windows)
 * @param int $wouldblock - The optional third argument is set to 1 if
 *   the lock would block (EWOULDBLOCK errno condition). (not supported on
 *   Windows)
 *
 * @return bool -
 */
<<__Native>>
function flock(resource $handle,
               int $operation,
               int &$wouldblock): bool;

/**
 * Match filename against a pattern
 *
 * @param string $pattern - The shell wildcard pattern.
 * @param string $string - The tested string. This function is especially
 *   useful for filenames, but may also be used on regular strings.   The
 *   average user may be used to shell patterns or at least in their
 *   simplest form to '?' and '*' wildcards so using fnmatch() instead of
 *   preg_match() for frontend search expression input may be way more
 *   convenient for non-programming users.
 * @param int $flags - The value of flags can be any combination of the
 *   following flags, joined with the binary OR (|) operator.   A list of
 *   possible flags for fnmatch()     Flag Description     FNM_NOESCAPE
 *   Disable backslash escaping.    FNM_PATHNAME  Slash in string only
 *   matches slash in the given pattern.    FNM_PERIOD  Leading period in
 *   string must be exactly matched by period in the given pattern.  
 *   FNM_CASEFOLD  Caseless match. Part of the GNU extension.
 *
 * @return bool - Returns TRUE if there is a match, FALSE otherwise.
 */
<<__Native>>
function fnmatch(string $pattern,
                 string $string,
                 int $flags): bool;

/**
 * Opens file or URL
 *
 * @param string $filename - If filename is of the form "scheme://...",
 *   it is assumed to be a URL and PHP will search for a protocol handler
 *   (also known as a wrapper) for that scheme. If no wrappers for that
 *   protocol are registered, PHP will emit a notice to help you track
 *   potential problems in your script and then continue as though filename
 *   specifies a regular file.   If PHP has decided that filename specifies
 *   a local file, then it will try to open a stream on that file. The file
 *   must be accessible to PHP, so you need to ensure that the file access
 *   permissions allow this access. If you have enabled , or open_basedir
 *   further restrictions may apply.   If PHP has decided that filename
 *   specifies a registered protocol, and that protocol is registered as a
 *   network URL, PHP will check to make sure that allow_url_fopen is
 *   enabled. If it is switched off, PHP will emit a warning and the fopen
 *   call will fail.    The list of supported protocols can be found in .
 *   Some protocols (also referred to as wrappers) support context and/or
 *   options. Refer to the specific page for the protocol in use for a list
 *   of options which can be set. (e.g. value user_agent used by the http
 *   wrapper).    On the Windows platform, be careful to escape any
 *   backslashes used in the path to the file, or use forward slashes.
 * @param string $mode - The mode parameter specifies the type of access
 *   you require to the stream. It may be any of the following:   A list of
 *   possible modes for fopen() using mode     mode Description     'r'
 *   Open for reading only; place the file pointer at the beginning of the
 *   file.    'r+'  Open for reading and writing; place the file pointer at
 *   the beginning of the file.    'w'  Open for writing only; place the
 *   file pointer at the beginning of the file and truncate the file to
 *   zero length. If the file does not exist, attempt to create it.    'w+'
 *    Open for reading and writing; place the file pointer at the beginning
 *   of the file and truncate the file to zero length. If the file does not
 *   exist, attempt to create it.    'a'  Open for writing only; place the
 *   file pointer at the end of the file. If the file does not exist,
 *   attempt to create it.    'a+'  Open for reading and writing; place the
 *   file pointer at the end of the file. If the file does not exist,
 *   attempt to create it.    'x'  Create and open for writing only; place
 *   the file pointer at the beginning of the file. If the file already
 *   exists, the fopen() call will fail by returning FALSE and generating
 *   an error of level E_WARNING. If the file does not exist, attempt to
 *   create it. This is equivalent to specifying O_EXCL|O_CREAT flags for
 *   the underlying open(2) system call.    'x+'  Create and open for
 *   reading and writing; otherwise it has the same behavior as 'x'.    'c'
 *    Open the file for writing only. If the file does not exist, it is
 *   created. If it exists, it is neither truncated (as opposed to 'w'),
 *   nor the call to this function fails (as is the case with 'x'). The
 *   file pointer is positioned on the beginning of the file. This may be
 *   useful if it's desired to get an advisory lock (see flock()) before
 *   attempting to modify the file, as using 'w' could truncate the file
 *   before the lock was obtained (if truncation is desired, ftruncate()
 *   can be used after the lock is requested).    'c+'  Open the file for
 *   reading and writing; otherwise it has the same behavior as 'c'.      
 *    Different operating system families have different line-ending
 *   conventions. When you write a text file and want to insert a line
 *   break, you need to use the correct line-ending character(s) for your
 *   operating system. Unix based systems use \n as the line ending
 *   character, Windows based systems use \r\n as the line ending
 *   characters and Macintosh based systems use \r as the line ending
 *   character.   If you use the wrong line ending characters when writing
 *   your files, you might find that other applications that open those
 *   files will "look funny".   Windows offers a text-mode translation flag
 *   ('t') which will transparently translate \n to \r\n when working with
 *   the file. In contrast, you can also use 'b' to force binary mode,
 *   which will not translate your data. To use these flags, specify either
 *   'b' or 't' as the last character of the mode parameter.   The default
 *   translation mode depends on the SAPI and version of PHP that you are
 *   using, so you are encouraged to always specify the appropriate flag
 *   for portability reasons. You should use the 't' mode if you are
 *   working with plain-text files and you use \n to delimit your line
 *   endings in your script, but expect your files to be readable with
 *   applications such as notepad. You should use the 'b' in all other
 *   cases.   If you do not specify the 'b' flag when working with binary
 *   files, you may experience strange problems with your data, including
 *   broken image files and strange problems with \r\n characters.     For
 *   portability, it is strongly recommended that you always use the 'b'
 *   flag when opening files with fopen().     Again, for portability, it
 *   is also strongly recommended that you re-write code that uses or
 *   relies upon the 't' mode so that it uses the correct line endings and
 *   'b' mode instead.
 * @param bool $use_include_path - The optional third use_include_path
 *   parameter can be set to '1' or TRUE if you want to search for the file
 *   in the include_path, too.
 * @param resource $context -
 *
 * @return resource - Returns a file pointer resource on success, or
 *   FALSE on error.
 */
<<__Native>>
function fopen(string $filename,
               string $mode,
               bool $use_include_path = false,
               resource $context = null): resource;

/**
 * Output all remaining data on a file pointer
 *
 * @param resource $handle -
 *
 * @return int - If an error occurs, fpassthru() returns FALSE.
 *   Otherwise, fpassthru() returns the number of characters read from
 *   handle and passed through to the output.
 */
<<__Native>>
function fpassthru(resource $handle): int;

/**
 * Format line as CSV and write to file pointer
 *
 * @param resource $handle -
 * @param array $fields - An array of values.
 * @param string $delimiter - The optional delimiter parameter sets the
 *   field delimiter (one character only).
 * @param string $enclosure - The optional enclosure parameter sets the
 *   field enclosure (one character only).
 *
 * @return int - Returns the length of the written string.
 */
<<__Native>>
function fputcsv(resource $handle,
                 array $fields,
                 string $delimiter = ",",
                 string $enclosure = '"'): int;

/**
 * Binary-safe file read
 *
 * @param resource $handle -
 * @param int $length - Up to length number of bytes read.
 *
 * @return string - Returns the read string .
 */
<<__Native>>
function fread(resource $handle,
               int $length): string;

/**
 * Parses input from a file according to a format
 *
 * @param resource $handle -
 * @param string $format - The specified format as described in the
 *   sprintf() documentation.
 * @param mixed $... - The optional assigned values.
 *
 * @return mixed - If only two parameters were passed to this function,
 *   the values parsed will be returned as an array. Otherwise, if optional
 *   parameters are passed, the function will return the number of assigned
 *   values. The optional parameters must be passed by reference.
 */
<<__Native, __VariadicByRef>>
function fscanf(resource $handle,
                string $format,
                ...$args): mixed;

/**
 * Seeks on a file pointer
 *
 * @param resource $handle -
 * @param int $offset - The offset.   To move to a position before the
 *   end-of-file, you need to pass a negative value in offset and set
 *   whence to SEEK_END.
 * @param int $whence - whence values are:  SEEK_SET - Set position equal
 *   to offset bytes. SEEK_CUR - Set position to current location plus
 *   offset. SEEK_END - Set position to end-of-file plus offset.
 *
 * @return int - Upon success, returns 0; otherwise, returns -1.
 */
<<__Native>>
function fseek(resource $handle,
               int $offset,
               int $whence = SEEK_SET): int;

/**
 * Gets information about a file using an open file pointer
 *
 * @param resource $handle -
 *
 * @return array - Returns an array with the statistics of the file; the
 *   format of the array is described in detail on the stat() manual page.
 */
<<__Native>>
function fstat(resource $handle): array;

/**
 * Returns the current position of the file read/write pointer
 *
 * @param resource $handle - The file pointer must be valid, and must
 *   point to a file successfully opened by fopen() or popen(). ftell()
 *   gives undefined results for append-only streams (opened with "a"
 *   flag).
 *
 * @return int - Returns the position of the file pointer referenced by
 *   handle as an integer; i.e., its offset into the file stream.   If an
 *   error occurs, returns FALSE.
 */
<<__Native>>
function ftell(resource $handle): int;

/**
 * Truncates a file to a given length
 *
 * @param resource $handle - The file pointer.    The handle must be open
 *   for writing.
 * @param int $size - The size to truncate to.    If size is larger than
 *   the file then the file is extended with null bytes.   If size is
 *   smaller than the file then the file is truncated to that size.
 *
 * @return bool -
 */
<<__Native>>
function ftruncate(resource $handle,
                   int $size): bool;

/**
 * Binary-safe file write
 *
 * @param resource $handle -
 * @param string $string - The string that is to be written.
 * @param int $length - If the length argument is given, writing will
 *   stop after length bytes have been written or the end of string is
 *   reached, whichever comes first.   Note that if the length argument is
 *   given, then the magic_quotes_runtime configuration option will be
 *   ignored and no slashes will be stripped from string.
 *
 * @return int - fwrite() returns the number of bytes written, or FALSE
 *   on error.
 */
<<__Native>>
function fwrite(resource $handle,
                string $string,
                int $length = 0): int;

/**
 * Binary-safe file write
 *
 * @param resource $handle -
 * @param string $string - The string that is to be written.
 * @param int $length - If the length argument is given, writing will
 *   stop after length bytes have been written or the end of string is
 *   reached, whichever comes first.   Note that if the length argument is
 *   given, then the magic_quotes_runtime configuration option will be
 *   ignored and no slashes will be stripped from string.
 *
 * @return int - fwrite() returns the number of bytes written, or FALSE
 *   on error.
 */
<<__Native>>
function fputs(resource $handle,
                string $string,
                int $length = 0): int;

/**
 * Find pathnames matching a pattern
 *
 * @param string $pattern - The pattern. No tilde expansion or parameter
 *   substitution is done.
 * @param int $flags - Valid flags:    GLOB_MARK - Adds a slash to each
 *   directory returned     GLOB_NOSORT - Return files as they appear in
 *   the directory (no sorting). When this flag is not used, the pathnames
 *   are sorted alphabetically     GLOB_NOCHECK - Return the search pattern
 *   if no files matching it were found     GLOB_NOESCAPE - Backslashes do
 *   not quote metacharacters     GLOB_BRACE - Expands {a,b,c} to match
 *   'a', 'b', or 'c'     GLOB_ONLYDIR - Return only directory entries
 *   which match the pattern     GLOB_ERR - Stop on read errors (like
 *   unreadable directories), by default errors are ignored.
 *
 * @return array - Returns an array containing the matched
 *   files/directories, an empty array if no file matched or FALSE on
 *   error.    On some systems it is impossible to distinguish between
 *   empty match and an error.
 */
<<__Native>>
function glob(string $pattern,
              int $flags): array;

/**
 * Tells whether the filename is a directory
 *
 * @param string $filename - Path to the file. If filename is a relative
 *   filename, it will be checked relative to the current working
 *   directory. If filename is a symbolic or hard link then the link will
 *   be resolved and checked. If you have enabled , or open_basedir further
 *   restrictions may apply.
 *
 * @return bool - Returns TRUE if the filename exists and is a directory,
 *   FALSE otherwise.
 */
<<__Native>>
function is_dir(string $filename): bool;

/**
 * Tells whether the filename is executable
 *
 * @param string $filename - Path to the file.
 *
 * @return bool - Returns TRUE if the filename exists and is executable,
 *   or FALSE on error.
 */
<<__Native>>
function is_executable(string $filename): bool;

/**
 * Tells whether the filename is a regular file
 *
 * @param string $filename - Path to the file.
 *
 * @return bool - Returns TRUE if the filename exists and is a regular
 *   file, FALSE otherwise.
 */
<<__Native>>
function is_file(string $filename): bool;

/**
 * Tells whether the filename is a symbolic link
 *
 * @param string $filename - Path to the file.
 *
 * @return bool - Returns TRUE if the filename exists and is a symbolic
 *   link, FALSE otherwise.
 */
<<__Native>>
function is_link(string $filename): bool;

/**
 * Tells whether a file exists and is readable
 *
 * @param string $filename - Path to the file.
 *
 * @return bool - Returns TRUE if the file or directory specified by
 *   filename exists and is readable, FALSE otherwise.
 */
<<__Native>>
function is_readable(string $filename): bool;

/**
 * Tells whether the file was uploaded via HTTP POST
 *
 * @param string $filename - The filename being checked.
 *
 * @return bool -
 */
<<__Native>>
function is_uploaded_file(string $filename): bool;

/**
 * Tells whether the filename is writable
 *
 * @param string $filename - The filename being checked.
 *
 * @return bool - Returns TRUE if the filename exists and is writable.
 */
<<__Native>>
function is_writable(string $filename): bool;

/**
 * Tells whether the filename is writable
 *
 * @param string $filename - The filename being checked.
 *
 * @return bool - Returns TRUE if the filename exists and is writable.
 */
<<__Native>>
function is_writeable(string $filename): bool;

/**
 * Changes group ownership of symlink
 *
 * @param string $filename - Path to the symlink.
 * @param mixed $group - The group specified by name or number.
 *
 * @return bool -
 */
<<__Native>>
function lchgrp(string $filename,
                mixed $group): bool;

/**
 * Changes user ownership of symlink
 *
 * @param string $filename - Path to the file.
 * @param mixed $user - User name or number.
 *
 * @return bool -
 */
<<__Native>>
function lchown(string $filename,
                mixed $user): bool;

/**
 * Create a hard link
 *
 * @param string $target - Target of the link.
 * @param string $link - The link name.
 *
 * @return bool -
 */
<<__Native>>
function link(string $target,
              string $link): bool;

/**
 * Gets information about a link
 *
 * @param string $path - Path to the link.
 *
 * @return int - linkinfo() returns the st_dev field of the Unix C stat
 *   structure returned by the lstat system call. Returns 0 or FALSE in
 *   case of error.
 */
<<__Native>>
function linkinfo(string $path): int;

/**
 * Gives information about a file or symbolic link
 *
 * @param string $filename - Path to a file or a symbolic link.
 *
 * @return array - See the manual page for stat() for information on the
 *   structure of the array that lstat() returns. This function is
 *   identical to the stat() function except that if the filename parameter
 *   is a symbolic link, the status of the symbolic link is returned, not
 *   the status of the file pointed to by the symbolic link.
 */
<<__Native>>
function lstat(string $filename): array;

/**
 * Makes directory
 *
 * @param string $pathname - The directory path.
 * @param int $mode - The mode is 0777 by default, which means the widest
 *   possible access. For more information on modes, read the details on
 *   the chmod() page.    mode is ignored on Windows.    Note that you
 *   probably want to specify the mode as an octal number, which means it
 *   should have a leading zero. The mode is also modified by the current
 *   umask, which you can change using umask().
 * @param bool $recursive - Allows the creation of nested directories
 *   specified in the pathname.
 * @param resource $context -
 *
 * @return bool -
 */
<<__Native>>
function mkdir(string $pathname,
               int $mode = 0777,
               bool $recursive = false,
               resource $context): bool;

/**
 * Moves an uploaded file to a new location
 *
 * @param string $filename - The filename of the uploaded file.
 * @param string $destination - The destination of the moved file.
 *
 * @return bool - Returns TRUE on success.   If filename is not a valid
 *   upload file, then no action will occur, and move_uploaded_file() will
 *   return FALSE.   If filename is a valid upload file, but cannot be
 *   moved for some reason, no action will occur, and move_uploaded_file()
 *   will return FALSE. Additionally, a warning will be issued.
 */
<<__Native>>
function move_uploaded_file(string $filename,
                            string $destination): bool;

/**
 * Parse a configuration file
 *
 * @param string $filename - The filename of the ini file being parsed.
 * @param bool $process_sections - By setting the process_sections
 *   parameter to TRUE, you get a multidimensional array, with the section
 *   names and settings included. The default for process_sections is FALSE
 * @param int $scanner_mode - Can either be INI_SCANNER_NORMAL (default)
 *   or INI_SCANNER_RAW. If INI_SCANNER_RAW is supplied, then option values
 *   will not be parsed.
 *
 * @return array - The settings are returned as an associative array on
 *   success, and FALSE on failure.
 */
<<__Native>>
function parse_ini_file(string $filename,
                        bool $process_sections = false,
                        int $scanner_mode = INI_SCANNER_NORMAL): array;

/**
 * Parse a configuration string
 *
 * @param string $ini - The contents of the ini file being parsed.
 * @param bool $process_sections - By setting the process_sections
 *   parameter to TRUE, you get a multidimensional array, with the section
 *   names and settings included. The default for process_sections is FALSE
 * @param int $scanner_mode - Can either be INI_SCANNER_NORMAL (default)
 *   or INI_SCANNER_RAW. If INI_SCANNER_RAW is supplied, then option values
 *   will not be parsed.
 *
 * @return array - The settings are returned as an associative array on
 *   success, and FALSE on failure.
 */
<<__Native>>
function parse_ini_string(string $ini,
                          bool $process_sections = false,
                          int $scanner_mode = INI_SCANNER_NORMAL): array;

/**
 * Returns information about a file path
 *
 * @param string $path - The path to be parsed.
 * @param int $options - If present, specifies a specific element to be
 *   returned; one of PATHINFO_DIRNAME, PATHINFO_BASENAME,
 *   PATHINFO_EXTENSION or PATHINFO_FILENAME.  If options is not specified,
 *   returns all available elements.
 *
 * @return mixed - If the options parameter is not passed, an associative
 *   array containing the following elements is returned: dirname,
 *   basename, extension (if any), and filename.    If the path has more
 *   than one extension, PATHINFO_EXTENSION returns only the last one and
 *   PATHINFO_FILENAME only strips the last one. (see first example below).
 *       If the path does not have an extension, no extension element will
 *   be returned (see second example below).    If options is present,
 *   returns a string containing the requested element.
 */
<<__Native>>
function pathinfo(string $path,
                  int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME): mixed;

/**
 * Closes process file pointer
 *
 * @param resource $handle - The file pointer must be valid, and must
 *   have been returned by a successful call to popen().
 *
 * @return int - Returns the termination status of the process that was
 *   run. In case of an error then -1 is returned.
 */
<<__Native>>
function pclose(resource $handle): int;

/**
 * Opens process file pointer
 *
 * @param string $command - The command
 * @param string $mode - The mode
 *
 * @return resource - Returns a file pointer identical to that returned
 *   by fopen(), except that it is unidirectional (may only be used for
 *   reading or writing) and must be closed with pclose(). This pointer may
 *   be used with fgets(), fgetss(), and fwrite(). When the mode is 'r',
 *   the returned file pointer equals to the STDOUT of the command, when
 *   the mode is 'w', the returned file pointer equals to the STDIN of the
 *   command.   If an error occurs, returns FALSE.
 */
<<__Native>>
function popen(string $command,
               string $mode): resource;

/**
 * Outputs a file
 *
 * @param string $filename - The filename being read.
 * @param bool $use_include_path - You can use the optional second
 *   parameter and set it to TRUE, if you want to search for the file in
 *   the include_path, too.
 * @param resource $context - A context stream resource.
 *
 * @return int - Returns the number of bytes read from the file. If an
 *   error occurs, FALSE is returned and unless the function was called as
 *   @readfile(), an error message is printed.
 */
<<__Native>>
function readfile(string $filename,
                  bool $use_include_path = false,
                  resource $context): int;

/**
 * Returns the target of a symbolic link
 *
 * @param string $path - The symbolic link path.
 *
 * @return string - Returns the contents of the symbolic link path or
 *   FALSE on error.
 */
<<__Native>>
function readlink(string $path): string;

/**
 * Returns the target of a symbolic link
 *
 * @param string $path - The symbolic link path.
 *
 * @return string - Returns the contents of the symbolic link path or
 *   FALSE on error.
 */
<<__Native, __HipHopSpecific>>
function readlink_internal(string $path): string;

/**
 * Get realpath cache entries
 *
 * @return array - Returns an array of realpath cache entries. The keys
 *   are original path entries, and the values are arrays of data items,
 *   containing the resolved path, expiration date, and other options kept
 *   in the cache.
 */
<<__Native>>
function realpath_cache_get(): array;

/**
 * Get realpath cache size
 *
 * @return int - Returns how much memory realpath cache is using.
 */
<<__Native>>
function realpath_cache_size(): int;

/**
 * Returns canonicalized absolute pathname
 *
 * @param string $path - The path being checked.   Whilst a path must be
 *   supplied, the value can be blank or NULL In these cases, the value is
 *   interpreted as the current directory.
 *
 * @return string - Returns the canonicalized absolute pathname on
 *   success. The resulting path will have no symbolic link, '/./' or
 *   '/../' components.   realpath() returns FALSE on failure, e.g. if the
 *   file does not exist.    The running script must have executable
 *   permissions on all directories in the hierarchy, otherwise realpath()
 *   will return FALSE.
 */
<<__Native>>
function realpath(string $path): string;

/**
 * Renames a file or directory
 *
 * @param string $oldname - The old name. The wrapper used in oldname
 *   must match the wrapper used in newname.
 * @param string $newname - The new name.
 * @param resource $context -
 *
 * @return bool -
 */
<<__Native>>
function rename(string $oldname,
                string $newname,
                resource $context): bool;

/**
 * Rewind the position of a file pointer
 *
 * @param resource $handle - The file pointer must be valid, and must
 *   point to a file successfully opened by fopen().
 *
 * @return bool -
 */
<<__Native>>
function rewind(resource $handle): bool;

/**
 * Removes directory
 *
 * @param string $dirname - Path to the directory.
 * @param resource $context -
 *
 * @return bool -
 */
<<__Native>>
function rmdir(string $dirname,
               resource $context): bool;

/**
 * Gives information about a file
 *
 * @param string $filename - Path to the file.
 *
 * @return array - stat() and fstat() result format    Numeric
 *   Associative Description     0 dev device number   1 ino inode number *
 *     2 mode inode protection mode   3 nlink number of links   4 uid
 *   userid of owner *   5 gid groupid of owner *   6 rdev device type, if
 *   inode device   7 size size in bytes   8 atime time of last access
 *   (Unix timestamp)   9 mtime time of last modification (Unix timestamp)
 *    10 ctime time of last inode change (Unix timestamp)   11 blksize
 *   blocksize of filesystem IO **   12 blocks number of 512-byte blocks
 *   allocated **     * On Windows this will always be 0.   ** Only valid
 *   on systems supporting the st_blksize type - other systems (e.g.
 *   Windows) return -1.   In case of error, stat() returns FALSE.
 */
<<__Native>>
function stat(string $filename): array;

/**
 * Creates a symbolic link
 *
 * @param string $target - Target of the link.
 * @param string $link - The link name.
 *
 * @return bool -
 */
<<__Native>>
function symlink(string $target,
                 string $link): bool;

/**
 * Create file with unique file name
 *
 * @param string $dir - The directory where the temporary filename will
 *   be created.
 * @param string $prefix - The prefix of the generated temporary
 *   filename.    Windows uses only the first three characters of prefix.
 *
 * @return string - Returns the new temporary filename (with path), or
 *   FALSE on failure.
 */
<<__Native>>
function tempnam(string $dir,
                 string $prefix): string;

/**
 * Creates a temporary file
 *
 * @return resource - Returns a file handle, similar to the one returned
 *   by fopen(), for the new file.
 */
<<__Native>>
function tmpfile(): resource;

/**
 * Sets access and modification time of file
 *
 * @param string $filename - The name of the file being touched.
 * @param int $time - The touch time. If time is not supplied, the
 *   current system time is used.
 * @param int $atime - If present, the access time of the given filename
 *   is set to the value of atime. Otherwise, it is set to the value passed
 *   to the time parameter. If neither are present, the current system time
 *   is used.
 *
 * @return bool -
 */
<<__Native>>
function touch(string $filename,
               int $time = 0,
               int $atime): bool;

/**
 * Changes the current umask
 *
 * @param int $mask - The new umask.
 *
 * @return int - umask() without arguments simply returns the current
 *   umask otherwise the old umask is returned.
 */
<<__Native>>
function umask(int $mask): int;

/**
 * Deletes a file
 *
 * @param string $filename - Path to the file.
 * @param resource $context -
 *
 * @return bool -
 */
<<__Native>>
function unlink(string $filename,
                resource $context): bool;

/**
 * Instances of Directory are created by calling the dir() function, not by
 * the new operator.
 */
class Directory {
  public $path;
  public $handle;

  public function __construct(string $path) {
    $this->path = $path;
    $this->handle = opendir($path);
  }

  /**
   * Close directory handle
   *
   * @param resource $dir_handle -
   *
   * @return void -
   */
  public function close(resource $dir_handle): void {
    closedir($this->handle);
  }

  /**
   * Read entry from directory handle
   *
   * @param resource $dir_handle -
   *
   * @return string -
   */
  public function read(resource $dir_handle): string {
    return readdir($this->handle);
  }

  /**
   * Rewind directory handle
   *
   * @param resource $dir_handle -
   *
   * @return void -
   */
  public function rewind(resource $dir_handle): void {
    return rewinddir($this->handle);
  }

}

/**
 * Change directory
 *
 * @param string $directory - The new current directory
 *
 * @return bool -
 */
<<__Native>>
function chdir(string $directory): bool;

/**
 * Change the root directory
 *
 * @param string $directory - The path to change the root directory to.
 *
 * @return bool -
 */
<<__Native>>
function chroot(string $directory): bool;

/**
 * Close directory handle
 *
 * @param resource $dir_handle - The directory handle resource previously
 *   opened with opendir(). If the directory handle is not specified, the
 *   last link opened by opendir() is assumed.
 *
 * @return void -
 */
<<__Native>>
function closedir(resource $dir_handle): void;

/**
 * Return an instance of the Directory class
 *
 * @param string $directory -
 * @param resource $context -
 *
 * @return Directory - Returns an instance of Directory, or NULL with
 *   wrong parameters, or FALSE in case of another error.
 */
<<__Native>>
function dir(string $directory,
             resource $context): Directory;

/**
 * Gets the current working directory
 *
 * @return string - Returns the current working directory on success, or
 *   FALSE on failure.   On some Unix variants, getcwd() will return FALSE
 *   if any one of the parent directories does not have the readable or
 *   search mode set, even if the current directory does. See chmod() for
 *   more information on modes and permissions.
 */
<<__Native>>
function getcwd(): string;

/**
 * Open directory handle
 *
 * @param string $path - The directory path that is to be opened
 * @param resource $context - For a description of the context parameter,
 *   refer to the streams section of the manual.
 *
 * @return resource - Returns a directory handle resource on success, or
 *   FALSE on failure.   If path is not a valid directory or the directory
 *   can not be opened due to permission restrictions or filesystem errors,
 *   opendir() returns FALSE and generates a PHP error of level  E_WARNING.
 *   You can suppress the error output of opendir() by prepending '@' to
 *   the front of the function name.
 */
<<__Native>>
function opendir(string $path,
                 resource $context): resource;

/**
 * Read entry from directory handle
 *
 * @param resource $dir_handle - The directory handle resource previously
 *   opened with opendir(). If the directory handle is not specified, the
 *   last link opened by opendir() is assumed.
 *
 * @return string - Returns the entry name on success.
 */
<<__Native>>
function readdir(resource $dir_handle): string;

/**
 * Rewind directory handle
 *
 * @param resource $dir_handle - The directory handle resource previously
 *   opened with opendir(). If the directory handle is not specified, the
 *   last link opened by opendir() is assumed.
 *
 * @return void -
 */
<<__Native>>
function rewinddir(resource $dir_handle): void;

/**
 * List files and directories inside the specified path
 *
 * @param string $directory - The directory that will be scanned.
 * @param int $sorting_order - By default, the sorted order is
 *   alphabetical in ascending order. If the optional sorting_order is set
 *   to SCANDIR_SORT_DESCENDING, then the sort order is alphabetical in
 *   descending order. If it is set to SCANDIR_SORT_NONE then the result is
 *   unsorted.
 * @param resource $context - For a description of the context parameter,
 *   refer to the streams section of the manual.
 *
 * @return array - Returns an array of filenames on success, or FALSE on
 *   failure. If directory is not a directory, then boolean FALSE is
 *   returned, and an error of level E_WARNING is generated.
 */
<<__Native>>
function scandir(string $directory,
                 int $sorting_order = SCANDIR_SORT_ASCENDING,
                 resource $context): array;

/**
 * Calculates the md5 hash of a given file
 *
 * @param string $filename - The filename
 * @param bool $raw_output - When TRUE, returns the digest in raw binary
 *   format with a length of 16.
 *
 * @return string - Returns a string on success, FALSE otherwise.
 */
<<__Native>>
function md5_file(string $filename,
                  bool $raw_output = false): string;

/**
 * Calculate the sha1 hash of a file
 *
 * @param string $filename - The filename of the file to hash.
 * @param bool $raw_output - When TRUE, returns the digest in raw binary
 *   format with a length of 20.
 *
 * @return string - Returns a string on success, FALSE otherwise.
 */
<<__Native>>
function sha1_file(string $filename,
                   bool $raw_output = false): string;